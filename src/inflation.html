
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Mesh Inflation | Zhonghua Xi | MASC | GMU</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {                
                background-color: #fff;                
                margin: 0px;
                overflow: hidden;
            }
            #info {
                position: absolute;
                top: 10px;
                width: 100%;
                text-align: center;
                z-index: 100;
                display:block;
                pointer-events:none;
            }
            #info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
        </style>
        <link rel="stylesheet" type="text/css" href="style/main.css">
    </head>

    <body>
        <div id="info">
            <div>Mesh Inflation</div>
            <div> Drop OBJ file onto the canvas | Press space to inflate</div>            
        </div>
        <div id="copyright" source="copyright.html">

        <script src="http://threejs.org/build/three.min.js"></script>
        <script src="http://threejs.org/examples/js/loaders/OBJLoader.js"></script>
        <script src="http://threejs.org/examples/js/controls/TrackballControls.js"></script>
        <script src="http://threejs.org/examples/js/libs/stats.min.js"></script>
        <script src="http://threejs.org/examples/js/libs/dat.gui.min.js"></script>
        <script src='https://code.jquery.com/jquery-2.1.3.min.js'></script>

        <script src="js/OBJLoader.js"></script>
        <script src="js/extension.js"></script>
        <script src="js/inflation.js"></script>

        <script>

            var container;

            var camera, scene, renderer;

            var controls, stats;

            var object;
            var mesh;
            var org_geometry;           

            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;

            var effectController = {
                pressure: 2.0,
                E: 10.0,
                step: 1.5               
            };
          
            var inflating = false;


            init();
            animate();


            function init() {

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                // camera
                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 2000 );                

                // scene

                scene = new THREE.Scene();

                var ambient = new THREE.AmbientLight( 0x666666 );
                scene.add( ambient );

                var directionalLight1 = new THREE.DirectionalLight( 0xffffff );
                directionalLight1.position.set( 1, -1, -0.3 );
                scene.add( directionalLight1 );

                var directionalLight2 = new THREE.DirectionalLight( 0xffffff );
                directionalLight1.position.set( 1, -1, 0.3 );
                scene.add( directionalLight2 );

                var gui = new dat.GUI();


                

                var valuesChanger = function() {                    
                    //resetGeometry();
                };                


                gui.add( effectController, "pressure", 1.0, 10.0, 1.0 ).onChange( valuesChanger );
                gui.add( effectController, "E", 1.0, 100, 1.0 ).onChange( valuesChanger );
                gui.add( effectController, "step", 1.1, 10, 0.1 ).onChange( valuesChanger );
              //  gui.close();

              
                

                var manager = new THREE.LoadingManager();
                manager.onProgress = function ( item, loaded, total ) {

                    console.log( item, loaded, total );

                };

                //var texture = new THREE.Texture();

                var onProgress = function ( xhr ) {
                    if ( xhr.lengthComputable ) {
                        var percentComplete = xhr.loaded / xhr.total * 100;
                        console.log( Math.round(percentComplete, 2) + '% downloaded' );
                    }
                };

                var onError = function ( xhr ) {
                };

                // model

                var loader = new OBJLoader( manager );
                loader.load( 'models/beethoven.obj', onOBJLoaded, onProgress, onError );

                //

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setClearColor( 0xffffff, 1 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );


                //

                window.addEventListener('resize', onWindowResize, false );
                window.addEventListener('keypress', onWindowKeyPress, false );

            }

            $("html").on("dragover", function(event) {
            event.preventDefault();  
            event.stopPropagation();
            //$(this).addClass('dragging');
        });

        function onOBJLoaded(obj) {
            // clear the scene
            if(object) scene.remove(object);
            object = obj;

            scene.add( obj );

            mesh = obj.children[0];

            mesh.geometry.normalize();

            org_geometry = mesh.geometry.clone();

            org_geometry.computeBoundingSphere();

            resetCamera();
        }

        function resetCamera() {            

            camera.position.z = 3.0;

            if(controls) controls.removeEventListener( 'change', render );

            // control
            controls = new THREE.TrackballControls( camera, renderer.domElement );

            controls.rotateSpeed = 5.0;
            controls.zoomSpeed = 1.5;
            controls.panSpeed = 0.8;

            controls.noZoom = false;
            controls.noPan = false;

            controls.staticMoving = true;
            controls.dynamicDampingFactor = 0.3;

            controls.keys = [ 65, 83, 68 ];

            controls.addEventListener( 'change', render );
        }

        $("html").on("dragleave", function(event) {
            event.preventDefault();  
            event.stopPropagation();
            //$(this).removeClass('dragging');
        });

        $("html").on("drop", function(event) {
            event.preventDefault();  
            event.stopPropagation();
            var files = event.originalEvent.dataTransfer.files;
            if(!files) return;

            // only read the first file
            var file = files[0];            
            
            if(!file.name.endsWith('.obj')) return;            
            
            var reader = new FileReader();          

            reader.onload = function(e) {
                var text = reader.result;
                var loader = new OBJLoader();
                var object = loader.parse(text);
                onOBJLoaded(object);
            }

            reader.readAsText(file, 'UTF-8');
            
            
        });

        function onWindowResize() {

            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function resetGeometry() {
            mesh.geometry = org_geometry.clone();
        }

        function onWindowKeyPress(e) {
            switch(e.keyCode)
            {
                // 'R': reset geometry
                case 114:                   
                    resetGeometry();
                    break;
                // 'space': toogle inflating mesh
                case 32:
                    inflating = !inflating
                    break;
            }

        }

        function updateInfalting() {
            inflate(org_geometry, mesh.geometry, effectController.pressure, effectController.E, Math.log(effectController.step)/100);            

            mesh.geometry.computeFaceNormals ();
            //mesh.geometry.computeVertexNormals ();
            mesh.geometry.verticesNeedUpdate = true;
            mesh.geometry.elementsNeedUpdate = true;
            mesh.geometry.normalsNeedUpdate = true;
        }
        

        function animate() {

            requestAnimationFrame( animate );

            if(inflating) updateInfalting();
            if(controls) controls.update();                          

            render();
        }

        function render() {             

            renderer.render( scene, camera );

        }

        $('div[source]').each(function(index){
            $(this).load($(this).attr('source'));
        });

        </script>       

    </body>
</html>
